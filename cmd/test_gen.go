// MIT License

// Copyright (c) The RAI Authors

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cmd

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	toolsimports "golang.org/x/tools/imports"
)

var (
	// genTestCmd
	genTestCmd = &cobra.Command{
		Use:   "gen",
		Short: "generate client and interface golang file",
		Long:  ``,
		Args:  cobra.NoArgs,
		Run:   genTest,
	}
	host string
)

func init() {
	genTestCmd.Flags().StringP("source", "s", "./tests/spec.json", "Input test spec source file; enables json mode.")
	genTestCmd.Flags().StringP("destination", "d", "./tests/client/client.go", "Output file; defaults to `./tests/client/client.go`.")
	genTestCmd.Flags().StringP("package", "p", "client", "Package name,defaults to `client`")
	genTestCmd.Flags().StringP("host", "", "127.0.0.1:8888", "Host address,defaults to `127.0.0.1:8888`")
	TestCmd.AddCommand(genTestCmd)
}

type spec struct {
	Name   string                  `json:"name"`
	Path   string                  `json:"path"`
	Method string                  `json:"method"`
	Header *map[string]interface{} `json:"header,omitempty"`
	Params *map[string]interface{} `json:"params,omitempty"`
	Query  *map[string]interface{} `json:"query,omitempty"`
	Body   *map[string]interface{} `json:"body,omitempty"`
}

func genTest(cmd *cobra.Command, _ []string) {
	source, err := cmd.Flags().GetString("source")
	if err != nil {
		log.Fatalf("Failed to get source arguments: %v", err)
	}

	destination, err := cmd.Flags().GetString("destination")
	if err != nil {
		log.Fatalf("Failed to get destination: %v", err)
	}

	pkgName, err := cmd.Flags().GetString("package")
	if err != nil {
		log.Fatalf("Failed to get package: %v", err)
	}

	if pkgName == "" {
		pkgName = "client"
	}

	host, err = cmd.Flags().GetString("host")
	if err != nil {
		log.Fatalf("Failed to get host: %v", err)
	}

	if _, err := os.Stat(source); os.IsNotExist(err) {
		log.Fatalf("Source path: %v", err)
	}

	data, err := os.ReadFile(source)
	if err != nil {
		log.Fatalf("Source file %s read: %v", source, err)
	}

	var specMap = make(map[string]map[string]spec)
	err = json.Unmarshal(data, &specMap)
	if err != nil {
		log.Fatalf("Source data %s unmarshal: %v", data, err)
	}

	g := NewGenerator(pkgName, source, destination, specMap)
	if err := g.GenSpecInterface(); err != nil {
		log.Fatalf("Failed generating interface: %v", err)
	}

	log.Printf("Generate %q completed.\n", path.Join(path.Dir(destination), "interface.go"))

	if err := g.Generate(); err != nil {
		log.Fatalf("Failed generating client: %v", err)
	}
	log.Printf("Generate %q completed.\n", destination)
}

func (g *generator) GenSpecInterface() error {
	g.p("// Code generated by bean test gen. DO NOT EDIT.")
	g.p("// Source: %v", g.source)
	g.p("")
	g.p("package %v", g.pkgName)
	g.p("")
	g.p("import (")
	g.in()
	g.p("%q", "github.com/go-resty/resty/v2")
	g.out()
	g.p(")")
	g.p("")

	for name, spec := range g.specMap {
		g.p("type %s interface{", name)
		g.in()
		for _, s := range spec {
			var sts = []string{"ctx context.Context"}
			st := "%s(" + strings.Join(sts, ",") + ") *resty.Response"
			g.p(st, s.Name)
		}
		g.out()
		g.p("}")
		g.p("")
	}

	bs, err := g.Output()
	if err != nil {
		return err
	}
	return write(path.Join(path.Dir(g.destination), "interface.go"), bs)
}

type generator struct {
	buf         *bytes.Buffer
	pkgName     string
	indent      string
	source      string                     // may be empty
	destination string                     // may be empty
	specMap     map[string]map[string]spec //
}

func NewGenerator(pkgName string, source string, destination string, specMap map[string]map[string]spec) *generator {
	return &generator{
		buf:         bytes.NewBuffer(nil),
		pkgName:     pkgName,
		source:      source,
		destination: destination,
		specMap:     specMap,
	}
}

func (g *generator) p(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(g.buf, g.indent+format+"\n", args...)
}

func (g *generator) in() {
	g.indent += "\t"
}

func (g *generator) out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[0 : len(g.indent)-1]
	}
}

func (g *generator) Generate() error {
	g.p("// Code generated by bean test gen. DO NOT EDIT.")
	g.p("// Source: %v", g.source)
	g.p("")

	g.p("package %v", g.pkgName)
	g.p("")
	g.p("import (")
	g.in()
	g.p("%q", "context")
	g.p("%q", "testing")
	g.p("%q", "github.com/go-resty/resty/v2")
	g.p("%q", "github.com/stretchr/testify/assert")
	g.p("%q", "github.com/retail-ai-inc/bean/v2/test")

	g.out()
	g.p(")")

	g.p(
		`type CommonParams struct {
					CartUUID     string
					ClientID     string
                    ClientSecret string
					AccessToken  string
                }`,
	)

	for name, intf := range g.specMap {
		if err := g.GenerateInterface(name, intf); err != nil {
			return err
		}
	}

	bs, err := g.Output()
	if err != nil {
		return err
	}

	return write(g.destination, bs)
}

func write(destination string, bs []byte) error {
	output := os.Stdout
	if destination != "" {
		if err := os.MkdirAll(filepath.Dir(destination), os.ModePerm); err != nil {
			return fmt.Errorf("unable to create directory: %w", err)
		}
		destinationFile, err := os.Create(destination)
		if err != nil {
			return fmt.Errorf("failed opening destination file: %w", err)
		}
		defer destinationFile.Close()
		output = destinationFile
	}

	if _, err := output.Write(bs); err != nil {
		return fmt.Errorf("failed writing to destination: %w", err)
	}
	return nil
}

// The name of the mock type to use for the given interface identifier.
func (g *generator) mockName(typeName string) string {
	trimTypeName := strings.TrimSuffix(typeName, "Handler")
	if trimTypeName == typeName {
		return typeName
	}
	return FirstLower(strings.TrimSuffix(typeName, "Handler") + "Client")
}

func (g *generator) restoreMockName(mockName string) string {
	trimMockName := strings.TrimSuffix(mockName, "Client")
	if trimMockName == mockName {
		return mockName
	}
	return FirstUpper(trimMockName + "Handler")
}

func FirstUpper(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func FirstLower(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func (g *generator) GenerateInterface(name string, intf map[string]spec) error {
	mockType := g.mockName(name)

	g.p("")
	g.p("// %v is a client which implements the %v interface.", mockType, name)
	g.p("type %v struct {", mockType)
	g.in()
	g.p("t           *testing.T")
	g.p("Params      CommonParams")
	g.p("http        *resty.Client")
	g.p("endPoint    string")
	g.p("accessToken string")
	g.out()
	g.p("}")
	g.p("")

	g.p("// New%v creates a new http client instance.", FirstUpper(mockType))
	g.p("func New%v(t *testing.T, params CommonParams) *%v {", FirstUpper(mockType), mockType)
	g.in()
	g.p("t.Helper()")
	g.p("")
	g.p("client := &%v{", mockType)
	g.in()
	g.p("t:           t,")
	g.p("Params:      params,")
	g.p("http:        test.NewHTTPClientWithoutRetry(),")
	g.p("endPoint:    \"http://%v\",", host)
	g.p("accessToken: params.AccessToken,")
	g.out()
	g.p("}")
	g.p("")
	g.p("return client")
	g.out()
	g.p("}")

	g.GenerateMethods(mockType, intf)

	return nil
}

func (g *generator) GenerateMethods(mockType string, intf map[string]spec) {
	for _, m := range intf {
		g.p("")
		err := g.GenerateMethod(mockType, m)
		if err != nil {
			log.Printf("Failed to generate methods: %+v\n", err)
			continue
		}
	}
}

// GenerateMethod generates a client method implementation.
// If non-empty, pkgOverride is the package in which unqualified types reside.
func (g *generator) GenerateMethod(mockType string, m spec) error {
	g.p("// %v http request method.", m.Name)
	g.p("func (c *%v) %v(ctx context.Context)*resty.Response {", mockType, m.Name)
	g.in()
	g.p("resp,err:=c.http.R().SetContext(ctx).")
	g.p("SetAuthToken(c.accessToken).")
	g.p(`SetHeaders(map[string]string{
			"Content-Type": "application/json",
            "Client-Id":c.Params.ClientID,
			"Client-Secret":c.Params.ClientSecret,
			"UUID":c.Params.CartUUID,
		}).`)

	mName := g.restoreMockName(mockType)
	if specs, ok := g.specMap[mName]; ok {
		if s, ok := specs[m.Name]; ok {
			if s.Header != nil && len(*s.Header) > 0 {
				for k, v := range *s.Header {
					var value string
					switch s := v.(type) {
					case string:
						value = s
					default:
						bs, err := json.Marshal(v)
						if err != nil {
							log.Printf("Failed to marshal header: %v", err)
						}
						value = string(bs)
					}

					g.p("SetHeader(%q,%q).", k, value)
				}
			}
			if s.Params != nil && len(*s.Params) > 0 {
				for k, v := range *s.Params {
					s.Path = strings.ReplaceAll(s.Path, fmt.Sprintf("/:%s", k), fmt.Sprintf("/%v", v))
				}
			}
			if s.Query != nil && len(*s.Query) > 0 {
				s.Path = s.Path + "?"
				var qs []string
				for k, v := range *s.Query {
					qs = append(qs, fmt.Sprintf("%s=%v", k, v))
				}
				s.Path = s.Path + strings.Join(qs, "&")
			}
			switch s.Method {
			case http.MethodGet:
				g.p(`Get(c.endPoint + "%v")`, s.Path)
			case http.MethodPost:
				if s.Body != nil && len(*s.Body) > 0 {
					g.p("SetBody(%v).", fmt.Sprintf("%#v", *s.Body))
				}

				g.p(`Post(c.endPoint + "%v")`, s.Path)
			case http.MethodDelete:
				g.p(`Delete(c.endPoint + "%v")`, s.Path)
			default:
				return errors.New("not support")
			}
		}
	} else {
		log.Fatalf("%q not exist", strings.Join([]string{g.restoreMockName(mockType), m.Name}, "."))
	}
	g.p("")
	g.p("assert.NoError(c.t,err)")
	g.p("")
	g.p("return resp")
	g.out()
	g.p("}")
	return nil
}

// Output returns the generator's output, formatted in the standard Go style.
func (g *generator) Output() ([]byte, error) {
	bs, err := io.ReadAll(g.buf)
	if err != nil {
		return nil, fmt.Errorf("failed to read buffer: %w\n", err)
	}
	if path.Ext(g.destination) == ".go" {
		src, err := toolsimports.Process(g.destination, bs, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to format generated source code: %w\n%s", err, g.buf.String())
		}
		return src, nil
	}

	return bs, nil
}
